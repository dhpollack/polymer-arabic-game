<link rel="import" href="../../bower_components/polymer/polymer.html">
<!-- Additional Component Load -->
<link rel="import" href="../../bower_components/core-icons/core-icons.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/core-icons/av-icons.html">
<script src="../../bower_components/recordrtc/RecordRTC.js"></script>

<dom-module id="word-recorder">
    <style>
    </style>
    <template>
      <div>
        <audio id="recAudio" src="" controls hidden></audio>
        <paper-icon-button id="recorderInit" icon="av:mic" on-tap="startRecording"></paper-icon-button>
        <!-- <paper-icon-button id="recorderStop" icon="av:stop" on-tap="stopRecording"></paper-icon-button>-->
        <paper-icon-button id="recorderPlay" icon="av:play-circle-fill" on-tap="playRecording"></paper-icon-button>
      </div>
    </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'word-recorder',
    properties: {
    },
    ready: function() {
      this.audio = this.$.recAudio;
    },
    startRecording: function() {
      initRec(this.audio);
    },
    stopRecording: function() {
      stopRec(this.audio);
    },
    playRecording: function() {
      playRec(this.audio);
    }  
  });
  /* RecordRTC Scripts */
  var recorder;
  var audioStream;
  var preventLongRec;
  var recLimit = 15000;
  function initRec(audioElem) {
    if(!audioStream) {
      // sets up recording environment
      navigator.getUserMedia(
        {audio: true},
        function(stream) {
          console.log("streaming started...");
          if (window.IsChrome) {
            stream = new window.MediaStream(stream.getAudioTracks());
          }
          audioStream = stream;
          
          // "audio" is a default type
          recorder = window.RecordRTC(stream, {
              type: 'audio'
          });
          recorder.startRecording();
          preventLongRec = setTimeout(function() {
              stopRec(audioElem);
              console.log("recording timed out after " + (recLimit / 1000) + " seconds.");
            }, recLimit);

        },
        function() { console.log("there was an error recording..."); } );
    } else {
      if(audioElem.readyState === 0) {
        clearTimeout(preventLongRec);
        stopRec(audioElem);
      } else {
        audioElem.src = '';
        recorder.startRecording();
        preventLongRec = setTimeout(function() {
            stopRec(audioElem);
            console.log("recording timed out after " + (recLimit / 1000) + " seconds.");
          }, recLimit);
      }
      console.log("readyState: " + audioElem.readyState);
      console.log("audio.src: " + audioElem.src);
      console.log("Stopping recording...");
    }
  }
  function stopRec(audioElem) {
    if(recorder && recorder.getBlob() === undefined) {
      recorder.stopRecording(function(url) {
        console.log("audio data url: " + url);
        audioElem.src = url;
        audioElem.muted = false;
        clearTimeout(preventLongRec);
      });
    } else {
      console.log("hmm, recorder isn't recording");
    }
  }
  function playRec(audioElem) {
    // if the user presses play before stop, the recording is stopped and then played
    if(recorder.getBlob() === undefined) {
      stopRec(audioElem);
      audioElem.onloadeddata = function() { audioElem.play(); };
    } else {
      console.log("play recording...");
      audioElem.play();
    }
  }
})();
</script>